{
  "question_name": "maximum-k-to-sort-a-permutation",
  "problem_metadata": {
    "questionId": "3950",
    "title": "Maximum K to Sort a Permutation",
    "titleSlug": "maximum-k-to-sort-a-permutation",
    "content": "<p>You are given an integer array <code>nums</code> of length <code>n</code>, where <code>nums</code> is a <strong><span data-keyword=\"permutation-array\">permutation</span></strong> of the numbers in the range <code>[0..n - 1]</code>.</p>\n\n<p>You may swap elements at indices <code>i</code> and <code>j</code> <strong>only if</strong> <code>nums[i] AND nums[j] == k</code>, where <code>AND</code> denotes the bitwise AND operation and <code>k</code> is a <strong>non-negative</strong> integer.</p>\n\n<p>Return the <strong>maximum</strong> value of <code>k</code> such that the array can be sorted in <strong>non-decreasing</strong> order using any number of such swaps. If <code>nums</code> is already sorted, return 0.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [0,3,2,1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Choose <code>k = 1</code>. Swapping <code>nums[1] = 3</code> and <code>nums[3] = 1</code> is allowed since <code>nums[1] AND nums[3] == 1</code>, resulting in a sorted permutation: <code>[0, 1, 2, 3]</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [0,1,3,2]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Choose <code>k = 2</code>. Swapping <code>nums[2] = 3</code> and <code>nums[3] = 2</code> is allowed since <code>nums[2] AND nums[3] == 2</code>, resulting in a sorted permutation: <code>[0, 1, 2, 3]</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [3,2,1,0]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Only <code>k = 0</code> allows sorting since no greater <code>k</code> allows the required swaps where <code>nums[i] AND nums[j] == k</code>.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n - 1</code></li>\n\t<li><code>nums</code> is a permutation of integers from <code>0</code> to <code>n - 1</code>.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"31.9K\", \"totalSubmission\": \"86.6K\", \"totalAcceptedRaw\": 31886, \"totalSubmissionRaw\": 86634, \"acRate\": \"36.8%\"}",
    "topicTags": [
      {
        "name": "Array",
        "slug": "array",
        "translatedName": null
      },
      {
        "name": "Bit Manipulation",
        "slug": "bit-manipulation",
        "translatedName": null
      }
    ],
    "hints": [
      "Take the bitwise AND of all elements that are not in their correct position."
    ]
  },
  "submissions": [
    {
      "id": "1729628193",
      "statusDisplay": "Wrong Answer",
      "lang": {
        "name": "python3",
        "verboseName": "Python3"
      },
      "runtime": 11895,
      "memory": 28792000,
      "timestamp": 1754797366,
      "title": "Maximum K to Sort a Permutation",
      "titleSlug": "maximum-k-to-sort-a-permutation",
      "runtimeDisplay": "N/A",
      "runtimePercentile": null,
      "memoryDisplay": "N/A",
      "memoryPercentile": null,
      "code": "from typing import List\n\nclass Solution:\n    def sortPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_k = 0\n        required_and = (1 << 30) - 1  # Initialize to all bits set\n        \n        for i in range(n):\n            if nums[i] != i:\n                # Find the index where the correct element (i) is located\n                j = nums.index(i)\n                current_and = nums[i] & nums[j]\n                required_and &= current_and\n                # Perform the swap to simulate sorting\n                nums[i], nums[j] = nums[j], nums[i]\n        \n        if required_and == ((1 << 30) - 1):\n            return 0  # Array was already sorted\n        else:\n            # Find the highest set bit in required_and\n            max_k = 0\n            temp = required_and\n            while temp > 0:\n                max_k = temp\n                temp &= (temp - 1)  # Clear the least significant bit\n            return max_k",
      "statusCode": 11,
      "user": {
        "username": "saachinnnn",
        "profile": {
          "realName": "iamkindagoated"
        }
      },
      "question": {
        "questionId": "3950",
        "titleSlug": "maximum-k-to-sort-a-permutation",
        "hasFrontendPreview": false
      },
      "notes": "",
      "flagType": "WHITE",
      "topicTags": [],
      "runtimeError": null,
      "compileError": null
    },
    {
      "id": "1729592521",
      "statusDisplay": "Time Limit Exceeded",
      "lang": {
        "name": "python3",
        "verboseName": "Python3"
      },
      "runtime": 11849,
      "memory": 20140000,
      "timestamp": 1754795829,
      "title": "Maximum K to Sort a Permutation",
      "titleSlug": "maximum-k-to-sort-a-permutation",
      "runtimeDisplay": "N/A",
      "runtimePercentile": null,
      "memoryDisplay": "N/A",
      "memoryPercentile": null,
      "code": "from typing import List\n\nclass Solution:\n    def sortPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        if nums == sorted(nums):\n            return 0\n        \n        sorted_nums = sorted(nums)\n        max_val = max(nums)\n        max_bits = max_val.bit_length()\n\n        def can_sort(k: int) -> bool:\n            parent = list(range(n))\n\n            def find(x):\n                while parent[x] != x:\n                    parent[x] = parent[parent[x]]\n                    x = parent[x]\n                return x\n\n            def union(a, b):\n                pa, pb = find(a), find(b)\n                if pa != pb:\n                    parent[pb] = pa\n\n            # Step 1: filter eligible indices (those having all bits of k set)\n            eligible = [i for i, v in enumerate(nums) if (v & k) == k]\n\n            # Step 2: group by value's AND with others\n            buckets = {}\n            for i in eligible:\n                buckets.setdefault(nums[i], []).append(i)\n\n            # Step 3: connect indices with same value (fast path)\n            for indices in buckets.values():\n                root = indices[0]\n                for idx in indices[1:]:\n                    union(root, idx)\n\n            # Step 4: connect by checking AND result == k (smaller groups)\n            eligible_vals = list(buckets.keys())\n            m = len(eligible_vals)\n            for i in range(m):\n                for j in range(i+1, m):\n                    if (eligible_vals[i] & eligible_vals[j]) == k:\n                        # connect one representative from each bucket\n                        union(buckets[eligible_vals[i]][0], buckets[eligible_vals[j]][0])\n\n            # Step 5: check if components match sorted positions\n            comp_vals = {}\n            comp_target = {}\n            for i in range(n):\n                r = find(i)\n                comp_vals.setdefault(r, []).append(nums[i])\n                comp_target.setdefault(r, []).append(sorted_nums[i])\n\n            for r in comp_vals:\n                if sorted(comp_vals[r]) != sorted(comp_target[r]):\n                    return False\n            return True\n\n        # Bit-by-bit greedy build of k\n        k = 0\n        for b in range(max_bits - 1, -1, -1):\n            candidate = k | (1 << b)\n            if can_sort(candidate):\n                k = candidate\n\n        return k\n",
      "statusCode": 14,
      "user": {
        "username": "saachinnnn",
        "profile": {
          "realName": "iamkindagoated"
        }
      },
      "question": {
        "questionId": "3950",
        "titleSlug": "maximum-k-to-sort-a-permutation",
        "hasFrontendPreview": false
      },
      "notes": "",
      "flagType": "WHITE",
      "topicTags": [],
      "runtimeError": null,
      "compileError": null
    },
    {
      "id": "1729591208",
      "statusDisplay": "Time Limit Exceeded",
      "lang": {
        "name": "python3",
        "verboseName": "Python3"
      },
      "runtime": 11928,
      "memory": 19208000,
      "timestamp": 1754795775,
      "title": "Maximum K to Sort a Permutation",
      "titleSlug": "maximum-k-to-sort-a-permutation",
      "runtimeDisplay": "N/A",
      "runtimePercentile": null,
      "memoryDisplay": "N/A",
      "memoryPercentile": null,
      "code": "from typing import List\n\nclass Solution:\n    def sortPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        if nums == sorted(nums):\n            return 0\n\n        sorted_nums = sorted(nums)\n        max_val = max(nums)\n        max_bits = max_val.bit_length()  # number of bits to consider\n\n        def can_sort(k: int) -> bool:\n            # DSU local to can_sort so find/union close over the same parent\n            parent = list(range(n))\n\n            def find(x: int) -> int:\n                while parent[x] != x:\n                    parent[x] = parent[parent[x]]\n                    x = parent[x]\n                return x\n\n            def union(a: int, b: int) -> None:\n                pa, pb = find(a), find(b)\n                if pa != pb:\n                    parent[pb] = pa\n\n            # build connectivity for this k\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if (nums[i] & nums[j]) == k:\n                        union(i, j)\n\n            # compare multisets inside each component with target positions\n            comp_vals = {}\n            comp_target = {}\n            for i in range(n):\n                r = find(i)\n                comp_vals.setdefault(r, []).append(nums[i])\n                comp_target.setdefault(r, []).append(sorted_nums[i])\n\n            for r in comp_vals:\n                if sorted(comp_vals[r]) != sorted(comp_target[r]):\n                    return False\n            return True\n\n        # Greedy build of k from high bit -> low bit\n        k = 0\n        for b in range(max_bits - 1, -1, -1):\n            candidate = k | (1 << b)\n            if can_sort(candidate):\n                k = candidate\n\n        return k\n",
      "statusCode": 14,
      "user": {
        "username": "saachinnnn",
        "profile": {
          "realName": "iamkindagoated"
        }
      },
      "question": {
        "questionId": "3950",
        "titleSlug": "maximum-k-to-sort-a-permutation",
        "hasFrontendPreview": false
      },
      "notes": "",
      "flagType": "WHITE",
      "topicTags": [],
      "runtimeError": null,
      "compileError": null
    }
  ]
}