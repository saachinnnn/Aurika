{
  "question_name": "twisted-mirror-path-count",
  "problem_metadata": {
    "questionId": "3938",
    "title": "Twisted Mirror Path Count",
    "titleSlug": "twisted-mirror-path-count",
    "content": "<p>Given an <code>m x n</code> binary grid <code>grid</code> where:</p>\n\n<ul>\n\t<li><code>grid[i][j] == 0</code> represents an empty cell, and</li>\n\t<li><code>grid[i][j] == 1</code> represents a mirror.</li>\n</ul>\n\n<p>A robot starts at the top-left corner of the grid <code>(0, 0)</code> and wants to reach the bottom-right corner <code>(m - 1, n - 1)</code>. It can move only <strong>right</strong> or <strong>down</strong>. If the robot attempts to move into a mirror cell, it is <strong>reflected</strong> before entering that cell:</p>\n\n<ul>\n\t<li>If it tries to move <strong>right</strong> into a mirror, it is turned <strong>down</strong> and moved into the cell directly below the mirror.</li>\n\t<li>If it tries to move <strong>down</strong> into a mirror, it is turned <strong>right</strong> and moved into the cell directly to the right of the mirror.</li>\n</ul>\n\n<p>If this reflection would cause the robot to move outside the <code>grid</code> boundaries, the path is considered invalid and should not be counted.</p>\n\n<p>Return the number of unique valid paths from <code>(0, 0)</code> to <code>(m - 1, n - 1)</code>.</p>\n\n<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p><strong>Note</strong>: If a reflection moves the robot into a mirror cell, the robot is immediately reflected again based on the direction it used to enter that mirror: if it entered while moving right, it will be turned down; if it entered while moving down, it will be turned right. This process will continue until either the last cell is reached, the robot moves out of bounds or the robot moves to a non-mirror cell.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = [[0,1,0],[0,0,1],[1,0,0]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">5</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<table style=\"border: 1px solid black;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th align=\"center\" style=\"border: 1px solid black;\">Number</th>\n\t\t\t<th align=\"left\" style=\"border: 1px solid black;\">Full Path</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td align=\"center\" style=\"border: 1px solid black;\">1</td>\n\t\t\t<td align=\"left\" style=\"border: 1px solid black;\">(0, 0) &rarr; (0, 1) [M] &rarr; (1, 1) &rarr; (1, 2) [M] &rarr; (2, 2)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td align=\"center\" style=\"border: 1px solid black;\">2</td>\n\t\t\t<td align=\"left\" style=\"border: 1px solid black;\">(0, 0) &rarr; (0, 1) [M] &rarr; (1, 1) &rarr; (2, 1) &rarr; (2, 2)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td align=\"center\" style=\"border: 1px solid black;\">3</td>\n\t\t\t<td align=\"left\" style=\"border: 1px solid black;\">(0, 0) &rarr; (1, 0) &rarr; (1, 1) &rarr; (1, 2) [M] &rarr; (2, 2)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td align=\"center\" style=\"border: 1px solid black;\">4</td>\n\t\t\t<td align=\"left\" style=\"border: 1px solid black;\">(0, 0) &rarr; (1, 0) &rarr; (1, 1) &rarr; (2, 1) &rarr; (2, 2)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td align=\"center\" style=\"border: 1px solid black;\">5</td>\n\t\t\t<td align=\"left\" style=\"border: 1px solid black;\">(0, 0) &rarr; (1, 0) &rarr; (2, 0) [M] &rarr; (2, 1) &rarr; (2, 2)</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<ul data-end=\"606\" data-start=\"521\">\n\t<li data-end=\"606\" data-start=\"521\">\n\t<p data-end=\"606\" data-start=\"523\"><code>[M]</code> indicates the robot attempted to enter a mirror cell and instead reflected.</p>\n\t</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = [[0,0],[0,0]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<table style=\"border: 1px solid black;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th align=\"center\" style=\"border: 1px solid black;\">Number</th>\n\t\t\t<th align=\"left\" style=\"border: 1px solid black;\">Full Path</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td align=\"center\" style=\"border: 1px solid black;\">1</td>\n\t\t\t<td align=\"left\" style=\"border: 1px solid black;\">(0, 0) &rarr; (0, 1) &rarr; (1, 1)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td align=\"center\" style=\"border: 1px solid black;\">2</td>\n\t\t\t<td align=\"left\" style=\"border: 1px solid black;\">(0, 0) &rarr; (1, 0) &rarr; (1, 1)</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">grid = </span>[[0,1,1],[1,1,0]]</p>\n\n<p><strong>Output:</strong> 1</p>\n\n<p><strong>Explanation:</strong></p>\n\n<table style=\"border: 1px solid black;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th align=\"center\" style=\"border: 1px solid black;\">Number</th>\n\t\t\t<th align=\"left\" style=\"border: 1px solid black;\">Full Path</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td align=\"center\" style=\"border: 1px solid black;\">1</td>\n\t\t\t<td align=\"left\" style=\"border: 1px solid black;\">(0, 0) &rarr; (0, 1) [M] &rarr; (1, 1) [M] &rarr; (1, 2)</td>\n\t\t</tr>\n\t</tbody>\n</table>\n<code>(0, 0) &rarr; (1, 0) [M] &rarr; (1, 1) [M] &rarr; (2, 1)</code> goes out of bounds, so it is invalid.</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li data-end=\"41\" data-start=\"21\"><code data-end=\"39\" data-start=\"21\">m == grid.length</code></li>\n\t<li data-end=\"67\" data-start=\"44\"><code data-end=\"65\" data-start=\"44\">n == grid[i].length</code></li>\n\t<li data-end=\"91\" data-start=\"70\"><code data-end=\"89\" data-start=\"70\">2 &lt;= m, n &lt;= 500</code></li>\n\t<li data-end=\"129\" data-start=\"94\"><code data-end=\"106\" data-start=\"94\">grid[i][j]</code> is either <code data-end=\"120\" data-is-only-node=\"\" data-start=\"117\">0</code> or <code data-end=\"127\" data-start=\"124\">1</code>.</li>\n\t<li data-end=\"169\" data-start=\"132\"><code data-end=\"167\" data-start=\"132\">grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"14.3K\", \"totalSubmission\": \"29.7K\", \"totalAcceptedRaw\": 14264, \"totalSubmissionRaw\": 29697, \"acRate\": \"48.0%\"}",
    "topicTags": [
      {
        "name": "Array",
        "slug": "array",
        "translatedName": null
      },
      {
        "name": "Dynamic Programming",
        "slug": "dynamic-programming",
        "translatedName": null
      },
      {
        "name": "Matrix",
        "slug": "matrix",
        "translatedName": null
      }
    ],
    "hints": [
      "Precompute, for each cell and each move (right/down), where you actually land if there’s a mirror next—store these \"jump\" targets in a <code>go[i][j][0/1]</code> table.",
      "Let <code>dp[i][j]</code> = number of ways to reach (i,j); set <code>dp[0][0] = 1</code>, then scan cells in row‑major order and for each <code>dp[i][j] > 0</code> add <code>dp[i][j]</code> into <code>dp[x][y]</code> for both precomputed moves.",
      "Always take additions modulo <code>10<sup>9</sup>+7</code>, and skip any jump target that falls outside the grid."
    ]
  },
  "submissions": [
    {
      "id": "1753651168",
      "statusDisplay": "Accepted",
      "lang": {
        "name": "python3",
        "verboseName": "Python3"
      },
      "runtime": 2549,
      "memory": 157476000,
      "timestamp": 1756566336,
      "title": "Twisted Mirror Path Count",
      "titleSlug": "twisted-mirror-path-count",
      "runtimeDisplay": "2549 ms",
      "runtimePercentile": 40.17100000000019,
      "memoryDisplay": "157.5 MB",
      "memoryPercentile": 31.62400000000011,
      "code": "from typing import List, Optional, Tuple\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def uniquePaths(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        # If start or end is a mirror, there is no valid path.\n        if grid[0][0] == 1 or grid[m-1][n-1] == 1:\n            return 0\n\n        # Memo for move simulation: (i, j, dir_idx) -> Optional[(ri, rj)]\n        # dir_idx: 0 => right (0,1), 1 => down (1,0)\n        memo = {}\n\n        def flip(di: int, dj: int) -> Tuple[int,int]:\n            # right -> down, down -> right\n            return (1, 0) if (di, dj) == (0, 1) else (0, 1)\n\n        def move(i: int, j: int, dir_idx: int) -> Optional[Tuple[int,int]]:\n            \"\"\"From empty cell (i,j), attempt to move in direction dir_idx.\n               Returns final empty cell (r,c) if move lands inside grid on an empty cell,\n               otherwise returns None (invalid/out-of-bounds).\"\"\"\n            key = (i, j, dir_idx)\n            if key in memo:\n                return memo[key]\n\n            di, dj = (0, 1) if dir_idx == 0 else (1, 0)\n            pos_i, pos_j = i, j\n\n            while True:\n                # neighbor we try to step into\n                ni, nj = pos_i + di, pos_j + dj\n                # if neighbor outside, move invalid\n                if not (0 <= ni < m and 0 <= nj < n):\n                    memo[key] = None\n                    return None\n\n                # if neighbor is empty -> we stop there\n                if grid[ni][nj] == 0:\n                    memo[key] = (ni, nj)\n                    return (ni, nj)\n\n                # neighbor is a mirror. Reflection happens BEFORE entering it:\n                # flip direction and move into the cell adjacent to that mirror in the flipped direction\n                di, dj = flip(di, dj)\n                pos_i, pos_j = ni + di, nj + dj\n\n                # if the reflection moves us out-of-bounds -> invalid path\n                if not (0 <= pos_i < m and 0 <= pos_j < n):\n                    memo[key] = None\n                    return None\n\n                # if that landing cell is empty -> we stop there\n                if grid[pos_i][pos_j] == 0:\n                    memo[key] = (pos_i, pos_j)\n                    return (pos_i, pos_j)\n\n                # otherwise pos is a mirror we \"moved into\" by the reflection;\n                # we must be immediately reflected again based on the direction we used to enter it:\n                # i.e. flip direction and continue the process.\n                di, dj = flip(di, dj)\n                # loop continues (next iteration will attempt pos + (di,dj))\n\n        # DP: push ways forward from each empty cell.\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    continue  # can't stand on a mirror\n                ways = dp[i][j]\n                if ways == 0:\n                    continue\n\n                # try move to the right\n                dest = move(i, j, 0)\n                if dest is not None:\n                    r, c = dest\n                    dp[r][c] = (dp[r][c] + ways) % MOD\n\n                # try move down\n                dest = move(i, j, 1)\n                if dest is not None:\n                    r, c = dest\n                    dp[r][c] = (dp[r][c] + ways) % MOD\n\n        return dp[m-1][n-1] % MOD\n\n\n# ----------------------------\n\n",
      "statusCode": 10,
      "user": {
        "username": "saachinnnn",
        "profile": {
          "realName": "iamkindagoated"
        }
      },
      "question": {
        "questionId": "3938",
        "titleSlug": "twisted-mirror-path-count",
        "hasFrontendPreview": false
      },
      "notes": "",
      "flagType": "WHITE",
      "topicTags": [],
      "runtimeError": null,
      "compileError": null
    }
  ]
}